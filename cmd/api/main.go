package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"clean-arch-go/internal/delivery/grpc"
	"clean-arch-go/internal/domain/entities"
	repo "clean-arch-go/internal/domain/repository"
	"clean-arch-go/internal/domain/service"
	"clean-arch-go/internal/middleware"
	httpHandler "clean-arch-go/internal/delivery/http/handler"
	"clean-arch-go/internal/pkg/config"
	"clean-arch-go/internal/pkg/database"
	"clean-arch-go/internal/pkg/i18n"
	"clean-arch-go/internal/pkg/redis"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"golang.org/x/text/language"
	"golang.org/x/time/rate"
	"gorm.io/gorm"

	_ "clean-arch-go/docs" // docs is generated by Swag CLI, you have to import it.
)

func main() {
	// Load cấu hình
	cfg := config.LoadConfig()

	// Khởi tạo logger
	log.Println("Starting application...")
	log.Printf("Environment: %s", cfg.App.Env)

	// Kết nối database
	db, err := database.NewDatabase(&cfg.Database)
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}

	// Tạo bảng nếu chưa tồn tại
	if err := db.Migrate(&entities.User{}, &entities.Book{}); err != nil {
		log.Fatalf("Failed to migrate database: %v", err)
	}

	// Kết nối Redis
	redisClient, err := redis.NewRedisClient(&cfg.Redis)
	if err != nil {
		log.Fatalf("Failed to connect to Redis: %v", err)
	}

	// Khởi tạo repositories
	userRepo := repo.NewUserRepository(db.DB)
	bookRepo := repo.NewBookRepository(db.DB)

	// Khởi tạo services
	authSvc := service.NewAuthService(userRepo, &cfg.JWT)
	bookSvc := service.NewBookService(bookRepo)

	// Khởi tạo HTTP server
	router := setupRouter(authSvc, bookSvc, redisClient, cfg)

	// Khởi tạo gRPC server
	grpcServer := grpc.NewServer(authSvc, bookSvc)

	// Chạy HTTP server trong một goroutine
	httpAddr := ":" + cfg.App.Port
	httpSrv := &http.Server{
		Addr:    httpAddr,
		Handler: router,
	}

	go func() {
		log.Printf("HTTP server listening on %s", httpAddr)
		if err := httpSrv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Failed to start HTTP server: %v", err)
		}
	}()

	// Chạy gRPC server trong một goroutine
	grpcAddr := ":50051"
	go func() {
		log.Printf("gRPC server listening on %s", grpcAddr)
		if err := grpcServer.Start(grpcAddr); err != nil {
			log.Fatalf("Failed to start gRPC server: %v", err)
		}
	}()

	// Chờ tín hiệu dừng (SIGINT hoặc SIGTERM)
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	log.Println("Shutting down server...")

	// Tắt HTTP server
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := httpSrv.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %v", err)
	}

	// Tắt gRPC server
	grpcServer.Stop()

	// Đóng kết nối Redis
	if err := redisClient.Close(); err != nil {
		log.Printf("Error closing Redis connection: %v", err)
	}

	log.Println("Server exiting")
}

// @title           Clean Architecture Go API
// @version         1.0
// @description     This is a sample server for Clean Architecture in Go.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io
// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html
// @host      localhost:8080
// @BasePath  /api
// @securityDefinitions.apikey  ApiKeyAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

func setupRouter(authSvc service.AuthService, bookSvc service.BookService, redisClient *redis.RedisClient, cfg *config.Config) *gin.Engine {
	// Initialize i18n
	localizer, err := i18n.NewLocalizer(language.English)
	if err != nil {
		log.Fatalf("Failed to initialize i18n: %v", err)
	}

	// Initialize Gin
	if cfg.App.Env == "production" {
		gin.SetMode(gin.ReleaseMode)
	}

	router := gin.Default()

	// Add i18n middleware
	router.Use(func(c *gin.Context) {
		acceptLang := c.GetHeader("Accept-Language")
		if acceptLang == "" {
			acceptLang = "en"
		}
		c.Set("localizer", localizer)
		c.Next()
	})

	// Middleware
	authMiddleware := middleware.NewAuthMiddleware(authSvc, localizer)
	rateLimiter := middleware.NewRateLimiter(redisClient, rate.Limit(cfg.RateLimit.Limit), cfg.RateLimit.Burst)

	// Swagger documentation
	swaggerURL := ginSwagger.URL("/swagger/doc.json") // The url pointing to API definition
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, swaggerURL))

	// Public API group
	public := router.Group("/api")
	{
		authHandler := httpHandler.NewAuthHandler(authSvc, localizer)
		public.POST("/register", authHandler.Register)
		public.POST("/login", authHandler.Login)

		// Apply rate limiting to public APIs
		public.Use(rateLimiter.Limit())
	}

	// Protected API group (requires authentication)
	authorized := router.Group("/api")
	authorized.Use(authMiddleware.AuthRequired())
	{
		bookHandler := httpHandler.NewBookHandler(bookSvc, localizer)
		authorized.GET("/books", bookHandler.ListBooks)
		authorized.POST("/books", bookHandler.CreateBook)
		authorized.GET("/books/:id", bookHandler.GetBook)
		authorized.PUT("/books/:id", bookHandler.UpdateBook)
		authorized.DELETE("/books/:id", bookHandler.DeleteBook)
	}

	// Health check endpoint
	router.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status":  "ok",
			"env":     cfg.App.Env,
			"version": "1.0.0",
		})
	})

	return router
}
